# 标准查询解析器

solr 默认查询解析器为 “lucene” 解析器

## 参数

| 参数 | 说明 |
| :--- | :--- |
| q | 使用标准查询语法的查询语句，该参数为必须的 |
| q.op | 查询表达式默认操作，取值为 AND \| OR，取代 solrconfig.xml里的配置 |
| df | 默认字段， ，取代 solrconfig.xml里的配置 |

## 响应

略

## 规格化词条

标准查询解析器把查询分解为词条和操作符，有 2 种词条：单个词条和短语

* 单个词条：单个的单词，例如 "test"，"hello"
* 短语：双引号包围的多个单词，例如 "hello dolly"

多个词条可以被逻辑操作符连接起来组成复杂查询

> 重要的是，查询和索引时使用相同的分析器来分解词条；否则，搜索时就可能产生意料之外的结果

## 词条编辑器

### 通配符搜索

| 类型 | 通配符 | 示例 |
| :--- | :--- | :--- |
| 匹配单个字符 | ? | te?t，匹配 test 和 text |
| 匹配多个字符 | \* | tes\*，匹配 test testing tester |

### 模糊搜索

solr 标准查询解析器支持模糊搜索，基于 Damerau-Levenshtein Distance 或 Edit Distance 算法。要执行模糊搜索，在单个词条末尾使用波浪符~，示例如下

> roam~ 匹配 roams，foam，foams，也匹配 roam 本身

还可以附带一个距离参数在波浪符后面，取值为 0~2，默认=2，示例如下

> roam~1 匹配 roams，foam，但是不匹配 foams，除非把距离修改为 2

### 临近搜索

临近搜索查找那些间隔一定距离的词条

要执行临近搜索，使用波浪符 ~ ，并在要搜索的短语末尾添加一个数字，示例如下

> "jakarta apache"~10，表示在文档里搜索 apache 和 jakarta，互相之间间隔 10 个单词

### 范围搜索

示例

> mod\_date:\[20020101 TO 20030101\]

范围查询不限于日期或数字，字符串也支持，此时按字典数序，示例：

> title:{Aida TO Carmen}

范围区间

* {x TO y}，表示 x 与 y 之间，不包含 x 和 y
* \[x TO y\]，表示 x 与 y 之间，且包含 x 和 y
* \[x TO y}，也是可以滴

注意：\* 号可以表示无限，在范围区间的两侧都可以使用

### 词条加权搜索

使用插入符号 ^ 来指定词条的相关性权重，在插入符后的数字是权重因子，例如：搜索 "jarkarta apache"，想要 "jakarta" 有更多的相关性，可以提高它的权重，如下

> jakarta^4 apache

也可以为短语加权，如下

> "jakarta apache"^4 "jakarta lucene"

默认的权重因子=1，虽然权重因子必须是正数，但是可以小于1，例如0.2

### 固定分数搜索

相同的查询条件，在不同的文档里有着不同的匹配度，该匹配度用分数表示。固定分数查询可以使一个查询对于任何匹配的文档都有一个固定的分数，格式如下

> &lt;查询语句&gt;^=&lt;分数&gt;

如果你仅需要匹配词条，而不关注匹配的词条在文档里出现的频率\/次数及词条在文档所有词条所占比例（这也是影响匹配度的因子），就可以使用固定分数查询。示例

> \(description:blue OR color:blue\)^=1.0 text:shoes

注意，匹配度由下述情况来决定

* 文档本身的权重，越大分数越大
* 字段的权重，越大分数越大
* 文档里的词条数量，越多分数越小
* 匹配的词条在文档里出现了多少次，越多分数越高
* 匹配的词条数目占文档总词条数目的比例，比例越大分数越高

## 规格化字段

数据在 solr 里是按字段进行索引的。搜索时可以指定字段进行搜索。在 schema 里定义了默认的字段，如果搜索时未指定字段，则会在默认字段里进行搜索

示例

> title:"The Right Way" AND text:go

如果 text 字段是默认字段，也可以这样

> title:"Do it right" AND go

字段只对**第一个词条**生效，后续的词条将在默认字段里搜索，如下

> title:Do it right，等同于 title:Do OR text: it right

## 逻辑操作符

| 逻辑操作符 | 符号 | 说明 |
| :--- | :--- | :--- |
| AND | && | 操作符 2 边所有词条都要在匹配中出现 |
| NOT | ! | 后续词条不得出现 |
| OR | \|\| | 操作符 2 边任意词条在匹配中出现 |
|  | + | 后续词条需要出现 |
|  | - | 禁止后续词条，即匹配的字段或文档里木有这个词条。和 ! 操作符是一样一样滴 |

**注意**

* 逻辑操作符全部大写

* 标准查询解析器支持所有逻辑操作符：AND，NOT，OR，+，-；DisMax 查询解析器只支持 +，-

* OR 操作符是默认的连接符号，这意味着如果 2 个词条之间木有逻辑操作符，那就表示有个隐含的 OR 操作符


## 特殊字符转义

如下字符出现在查询中时是有特别含义滴，若要查询字符本身需要转义

* * && \|\| ! \( \) { } \[ \] ^ " ~ \* ? : \/


转义符为反斜杠 \，查询 \(1+1\):2示例如下

> \\(1+1\\)\:2

## 组合词条成子查询

solr 支持用圆括号来组合查询，示例如下

> \(jakarta OR apache\) AND website

表示查询须匹配 website，且 jakarta 或 apache 至少一个

### 针对字段的组合查询

在单个字段上使用多个逻辑操作符，用圆括号来组合，示例

> title:\(+return +"pink panther"\)

## 注释

solr 支持 c 语言样式的注释，即 \/\* 注释 \*\/。注释可以内嵌在查询中，示例

> "jakarta apache" \/\* this is a comment in the middle of a normal query string \*\/ OR jakarta

## Lucene 查询解析器 和 solr 标准查询解析器差异

solr 标准查询解析器在如下方面和 lucene 查询解析器不同

* 范围查询的 \* 号

  * field:\[\* TO 100\] ，表示所有小于等于 100 的值
  * field:\[100 TO \*\] ，表示所有大于等于 100 的值
  * field:\[\* TO \*\]，表示所有值


* 在最顶层查询中，支持纯的负查询（所有条件都是禁止的查询）
  * -inStock:false ，表示所有 inStock 不为 false 的值
  * -field:\[\* TO \*\]，表示 field 值为空的


* FunctionQuery 语法挂钩：需要用引号将带圆括号的函数包围，如下第二例

  * \_val\_:myfield

  * \_val\_:"recip\(rord\(myfield\),1,2,3\)"



* 内嵌的查询语句支持任意类型的查询解析器
  * inStock:true OR {!dismax qf='name manu' v='ipod'}


* 支持特殊的 filter\(...\) 语法来指明某些查询子句应该被缓存到过滤器缓存\(filter cache\)，例如下面 3 个例子里的 inStock:true 会被缓存和重用

  * q=features:songs OR filter\(inStock:true\)

  * q=+manu:Apple +filter\(inStock:true\)

  * q=+manu:Apple & fq=inStock:true



* 范围查询 \("\[a TO z\]"\)，前缀查询 \("a\*"\)，通配符查询 \("a\*b"\) 都是固定分数的，即所有匹配的文档都有相同的分数

## 规格化日期和时间

字段类型为 TrieDateField 的，可以使用如下的语法

* timestamp:\[\* TO NOW\]

* createdate:\[1976-03-06T23:59:59.999Z TO \*\]

* createdate:\[1995-12-31T23:59:59.999Z TO 2007-03-06T00:00:00Z\]

* pubdate:\[NOW-1YEAR\/DAY TO NOW\/DAY+1DAY\]

* createdate:\[1976-03-06T23:59:59.999Z TO 1976-03-06T23:59:59.999Z+1YEAR\]

* createdate:\[1976-03-06T23:59:59.999Z\/YEAR TO 1976-03-06T23:59:59.999Z\]

